(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{603:function(n,e,o){"use strict";o.r(e);var t=o(12),r=Object(t.a)({},(function(){var n=this,e=n.$createElement,o=n._self._c||e;return o("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[o("h2",{attrs:{id:"_1-let和const"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_1-let和const"}},[n._v("#")]),n._v(" 1.let和const")]),n._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",[o("code",[n._v("const 命令\n- 声明一个不可改变的常量  => 不会改变内存地址指向的数据\n- 必须赋值\n- 与let类似,在其块级作用域生效\n- 不会变量提升 => 存在'暂时性死区'\n")])])]),o("h2",{attrs:{id:"_2-es6声明变量的六种方法"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_2-es6声明变量的六种方法"}},[n._v("#")]),n._v(" 2.ES6声明变量的六种方法")]),n._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",[o("code",[n._v("- let\n- var \n- const \n- function\n- import\n- class\n\n顶层对象的属性 => javascript败笔之一\n- 理解: 不会在编译时就会检测出变量声明错误的问题\n- 原因: window对象的产生是动态的的可能会出现变量同名问题\n- 总结: 当打开浏览器时才会检测变量声明的问题 \n=> 执行两步: \n        - (1) 查看Node的global对象\n        - (2) 查看浏览器的window对象\n")])])]),o("h2",{attrs:{id:"_3-变量的解构赋值"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_3-变量的解构赋值"}},[n._v("#")]),n._v(" 3.变量的解构赋值")]),n._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",[o("code",[n._v("- let [a,b,c] = [1,2,3];\n- let [foo,[[bar],baz]] = [1,[[2],3]]\n- let [x, ,y] = [1,2,3]; // x = 1,y = 3\n- let [x,y,z] = [1,2];  // z undefined 只声明未赋值\n\n允许指定默认值\n- let [foo = 'true'] = []; // foo = 'true'\n- let [x='a',y] = ['b']; // x='b',y undefined x值会被覆盖\n- let [x = y, y = 1] = []; //报错\n\n对象的解构赋值 => 会将对象的属性和值一一对应,没有依次顺序\n- let {foo} = {bar :'aaa'} // foo undefined\n- let {foo , bar} = {bar :'aaa',foo :'bbb'}  // foo :'bbb' , bar :'aaa';\n- const {log} = console // 将console的属性和方法中的log取出赋值给log\n  log('123')\n- 对象解构赋值案例\nconst node = {loc: {start: {line: 1,column: 5}}};\nlet { loc, loc: { start }, loc: { start: { line } } } = node;\n\nline // 1\nloc  // Object {start: Object}\nstart // Object {line: 1, column: 5}\n\n用途:\n(1).交换变量的值:\n    - let x = 1;\n    - let y = 2;\n    - [x,y] = [y,x]\n(2).从函数返回多个值:\n    - function example(){\n        return [1,2,3];\n    }\n    - let [a,b,c] = example();\n    - function example(){\n        return {\n            foo:1,\n            bar:2\n        };\n    }\n    - let {foo,bar} = example();\n(3).函数参数的定义:\n    - function f({x,y,z}){};\n    - f({x:2,y:1,z:3});\n(4).提取JSON数据:\n    - let JSON = {\n        name:'康振',\n        age:20,\n        sex:'男'；\n    }\n    - let {name,age,sex} = JSON;\n    - name = '康振',age = 20,sex = '男'\n(5).遍历map结构  => set方法可以自动删除重复的数值\n    - const map = new Map();\n    - map.set('first','hello');\n    - map.set('second','world');\n    - for(let [key,value] of map){\n        const { log } = console;\n        log(key + 'is' + value)\n    }\n")])])]),o("h2",{attrs:{id:"_4-字符串的拓展"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_4-字符串的拓展"}},[n._v("#")]),n._v(" 4.字符串的拓展")]),n._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",[o("code",[n._v("- 遍历字符串\nfor(let codePoint of 'foo'){\n    console.log(codePoint);\n}\n- 模板字符串\n直接使用`` 反引号 加上${内容}\n    - let name = 'Bob';\n      let age  = 20;\n      `${name} is ${age}` \n")])])]),o("h2",{attrs:{id:"_5-字符串的新增方法"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_5-字符串的新增方法"}},[n._v("#")]),n._v(" 5.字符串的新增方法")]),n._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",[o("code",[n._v("- String.fromCodePoint() 识别大于0xFFFF字符\n- String.raw() 返回一个斜杠(斜杠前面再加一个斜杠)\n- codePointAt() 正确返回UTF-16字符\n- includes() 返回布尔值,表示是否找到了参数字符串\n- startsWith() 返回布尔值,表示参数字符串是否在原字符串的头部\n- endsWith() 返回布尔值,表示参数字符串是否在原字符串的尾部\n- repeat() 返回一个新字符串,表示将原字符串重复n次\n- padStart(参数1,参数2) 补全字符串,参数1为长度,参数2为用什么字符串补全\n- trimStart() 删除头部空格\n- trimEnd() 删除尾部空格\n- matchAll() 是否匹配该正则表达式\n- repeatAll(寻找项,替换项) 替换所有满足的字符\n")])])]),o("h2",{attrs:{id:"_6-正则的拓展"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_6-正则的拓展"}},[n._v("#")]),n._v(" 6.正则的拓展")]),n._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",[o("code",[n._v("- 允许在构造函数中共同使用正则表达式和制定修饰符\n    - new RegExP(/abc/ig,'i').flags\n        - 后面的'i'会覆盖前面的修饰符\n- u修饰符 => Unicode模式 => 处理大于\\uFFFF字符\n    - var s = '𠮷';\n      /^.$/.test(s) // false\n      /^.$/u.test(s) // true\n    - 判断是否添加u修饰符\n        - .Unicode  // true\n- y修饰符 => 与g修饰符类似 => 全局匹配\n    - 判断是否添加y修饰符\n        - .sticky  // true\n- flags属性\n    - 返回正则表达式的修饰符\n")])])]),o("h2",{attrs:{id:"_7-数值的拓展"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_7-数值的拓展"}},[n._v("#")]),n._v(" 7.数值的拓展")]),n._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",[o("code",[n._v("- 7.1引入二进制和八进制\n    - 0b111110111 === 503 // true\n      0o767 === 503 // true\n- 7.2数值分隔符\n    - 使用下划线_作为分隔符\n    - 1000 === 1_000\n    - Number('123_456') // NaN\n      parseInt('123_456') // 123\n- 7.3Number.isFinite(),Number.isNaN()\n    - Number.isFinite() 判断是否有限\n    - Number.isNaN()    判断是否不是一个数字\n        - 如果参数类型不是NaN，Number.isNaN一律返回false\n    - Number.parseInt(),Number.parseFloat()\n        - 和ES5作用一样,减少全局性方法,移植到Number对象上\n    - Number.isInterger() \n        - 判断一个数是否为整数\n        - Number.isInteger('15') // false\n    - Number.EPSILON()\n        - 设置能够接受的误差范围\n        - Number.EPSILON * Math.pow(2,2)\n            - 5.551115123125783e-17 < Number.EPSILON * Math.pow(2, 2) // true\n    - Number.isSafeInteger()\n        - 精确表示-2^53到2^53之间\n- 7.4 Math对象拓展\n    - Math.trunc()\n        - 去掉小数部分\n    - Math.sign()\n        - 判断是正数、负数还是零\n        - 返回值\n            - 参数为正数，返回+1；\n              参数为负数，返回-1；\n              参数为 0，返回0；\n              参数为-0，返回-0;\n              其他值，返回NaN。\n    - Math.cbrt()\n        - 计算一个数的立方根 开立方根\n        - 会将字符串转换为Number\n    - Math.hypot()\n        - 返回所有参数的平方和的平方根\n        - Math.hypot(3, 4);  // 5\n- 7.5 BigInt数据类型\n    - 第8种数据类型\n    - 后缀必须加n\n    -  let num = 231321564n;\n       let num1 = 1234651321n;\n       console.log(num * num1);  // 可以确保精度\n       console.log(Number(num) * Number(num1));\n")])])]),o("h2",{attrs:{id:"_8-函数的拓展"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_8-函数的拓展"}},[n._v("#")]),n._v(" 8.函数的拓展")]),n._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",[o("code",[n._v("- 8.1 函数参数默认值\n    - ES6之前不能直接设置函数参数默认值\n    - ES6\n        - function fn(x,y = 'World'){\n          ...\n          }\n    - 函数的length属性\n        - 表示函数应该传的参数个数\n          - let length = (function (x, y, z = 5) { }).length\n            console.log(length); // 2 \n    - 作用域\n        - let foo = 'outer';\n          function bar(func =() => foo{\n            let foo = 'inner';\n            console.log(func());\n          })\n          bar(); // outer\n- 8.2 rest参数\n    - 该参数就是一个数组\n    - 代替arguments\n    - 不被length属性所包括\n- 8.3 严格模式\n    - 不能在函数参数使用了默认值、解构赋值、拓展运算符时将函数设为严格模式\n- 8.4 name属性\n    - 返回函数名\n        - const bar = function baz(){};\n          console.log(bar.name) // baz\n    - 构造函数\n        - (new Function).name //'anonymous'\n- 8.5 箭头函数\n    - let sum = (sum1,sum2) => sum1 + sum2;\n    - 箭头函数返回如果是一个对象,必须加上括号\n        - let getTempItem = id => ({ id: id, name: \"Temp\" });\n    - [1,2,3].map(x => x*x)\n    - 箭头函数的this指向问题\n    箭头函数没有自己的this,所以不能使用call、apply、bind来改变this指向\n    function foo() {\n        return () => {\n            return () => {\n                return () => {\n                    console.log('id:', this.id);\n                    };\n                };\n            };\n        }  \n    var f = foo.call({id: 1});           \n    var t1 = f.call({id: 2})()(); // id: 1\n    var t2 = f().call({id: 3})(); // id: 1\n    var t3 = f()().call({id: 4}); // id: 1\n    - 注意箭头函数的不可使用场景\n        - 定义一个对象时,不要给对象添加箭头函数\n        - 动态绑定this时,不要使用箭头函数\n        - 如果需要大量读写数据,不要使用箭头函数\n- 8.6 嵌套的箭头函数\n    - function insert(value){\n        return {into:function(array){\n            return {after:function(aftervalue){\n                array.splice(array.indexOf(aftervalue)+1,0,value);\n            }}\n        }}\n    }\n    insert(2).into([1,3]).after(1); // [1,2,3]\n\n    - 使用箭头函数\n     let result = (value) => ({\n        into: (array) => ({\n            after: (aftervalue) => {\n                array.splice(array.indexOf(aftervalue) + 1, 0, value);\n                return array;\n            }\n        })\n    })\n    console.log(result(2).into([1, 3]).after(1)); // [1,2,3]\n- 8.7 尾调用优化 => 注意只能在ES6严格模式下使用\n    - 尾调用是指一个函数中最后调用一个函数\n    - function f(x){\n        return g(x);\n    }\n    - 尾调用不一定出现在函数尾部,只要是最后一步操作即可\n    function f(x){\n        if(x>0){\n            return m(x);\n        }\n        return n(x)\n    }\n    - 尾调用优化\n    function f(x) {\n        let m = 1;\n        let n = 2;\n        return g(m+n);\n    }\n    => 等于\n    function f(x){\n        return g(3);\n    }\n    => 等于\n    g(3);\n    - 尾调用优化 => 不常用\n    由于以上代码只利用到内层函数的调用帧\n    所以只需要保留内层函数的调用帧\n    - 尾递归\n    函数内部调用自身\n    n  total\n    5   1\n    4   5\n    3   20\n    2   60\n    1   120\n    尾递归阶乘\n    function fn(n, total) {\n        if (n === 1) {\n            return total;\n        }\n        return fn(n - 1, n * total);\n    }\n    console.log(fn(5, 1));\n    尾调用斐波那契数列\n     function fn(n, num1 = 1, num2 = 1) {\n        if (n == 1 || n == 2) {\n            return 1;\n        }\n        return fn(n - 1, num1, num1 + num2)\n    }\n    - 尾调用不会导致栈溢出问题,从而节省内存空间\n    - 尾调用改写:\n    function tailFactorial(n, total) {\n        if (n === 1) return total;\n        return tailFactorial(n - 1, n * total);\n    }\n    在该函数外再设置一个函数,可以代替参数1的效果\n    function factorial(n) {\n        return tailFactorial(n, 1);\n    }\n    factorial(5) // 120\n- 8.8 函数参数的尾逗号\n    function clownsEverywhere(\n        param1,\n        param2,\n    ) { /* ... */ }\n    \n    clownsEverywhere(\n        'foo',\n        'bar',\n    );\n    即可以给函数增加尾参数\n- 8.9 Function.prototype.toString()\n    toString()方法返回函数代码本身,但会包含注释\n")])])]),o("h2",{attrs:{id:"_9-数组的拓展"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_9-数组的拓展"}},[n._v("#")]),n._v(" 9.数组的拓展")]),n._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",[o("code",[n._v("- 9.1 拓展元素符 => ...[1,2,3,4,5] 转换为一个参数序列\n    const arr = [1,2,3,4,5]\n    console.log(...arr); // 1 2 3 4 5\n    这种是转换为指定的数据类型\n    console.log([...arr]); // [1,2,3,4,5]\n    console.log({...arr}); // {1,2,3,4,5}\n- 9.2 替代函数的apply()方法\n    const arr = [1,2,3,4,5];\n    const arr1 = [6,7,8,9,10];\n    console.log(Math.max(...arr));\n- 9.3 拓展运算符的应用\n    - 9.3.1 复制数组\n        - const arr = [1,2,3];\n          原数组使用拓展字符串的数组形式\n          const NewArr1 = [...arr];\n          console.log(NewArr1);  \n          新数组使用拓展字符串的数组形式\n          const [...NewArr2] = arr;\n          console.log(NewArr2);\n    - 9.3.2 合并数组 \n        - 注意该方法是浅拷贝,都是对源数据的引用\n          const arr1 = [1, 2, 3];\n          const arr2 = [4, 5, 6];\n          const arr3 = [7, 8, 9];\n          console.log([...arr1,...arr2,...arr3]);\n    - 9.3.3 与解构赋值结合\n        - 注意必须将拓展运算符放在最后\n        - const [first, ...second] = [1, 2, 3, 4, 5];\n    - 9.3.4 字符串\n        - 9.3.4.1 字符串转数组\n        - let str = [...'Hello']\n          console.log(str); // [ \"h\", \"e\", \"l\", \"l\", \"o\" ]\n    - 9.3.5 iterator接口\n        - Number.prototype[Symbol.iterator] = function*() {\n          let i = 0;\n          let num = this.valueOf();\n          while (i < num) {\n              yield i++;\n              }\n          }\n          上面定义了Number类型的一个iterator的迭代接口\n          console.log([...5]) // [0, 1, 2, 3, 4]\n    - 9.3.6 Map和set结构,Generator函数\n        - Map \n          - let map = new Map();\n            map.set(1, 'one')\n            map.set(2, 'two')\n            map.set(3, 'three')\n            console.log([...map.keys()]); // [1,2,3]\n        - Generator\n          - const go = function* () {\n                yield 1;\n                yield 2;\n                yield 3;\n            }\n            console.log([...go()]); // [1,2,3]\n- 9.4 Array.from()\n    - 9.4.1 可以将伪数组或者可迭代对象转换为数组\n        - 伪数组\n            let divs = document.querySelectorAll('div');\n            console.log(Array.from(divs));\n        - 可迭代对象 Array、String、NodeList、伪数组、map、set、Arguments\n            let map = new Map();\n            map.set(1, 'one')\n            map.set(2, 'two')\n            map.set(3, 'three')\n            console.log(Array.from(map));\n    - 9.4.2 参入第二参数 类似map 数组遍历\n        - Array.from([1,2,3],(ele)=>console.log(ele))\n- 9.5 Array.of() 可以替代Array() 或者new Array()\n    - 9.5.1 将一组值转换位数组\n        - console.log(Array.of(1,2,3)); // [1,2,3]\n- 9.6 copyWithin()\n    -  console.log([0, 0, 0, 1, 2, 3].copyWithin(1, 3, 5)); // [0,1,2,1,2,3]\n- 9.7 find()和findIndex()\n    - find() 返回第一个目标值的值\n        - console.log([1, 2, 3, 4, 5].find(n => n > 4)); // 5\n    - findIndex() 返回第一个目标值的索引\n        - console.log([1, 2, 3, 4, 5].findIndex(n => n > 4)); // 5\n- 9.8 fill() 初始化数组值\n    -  console.log(Array.of('a', '4', '5').fill(10));\n- 9.9 entries(),keys()和values()\n    - 都可以使用for of遍历 => 因为具有iterator迭代器接口\n    - keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。\n- 9.10 includes()  比indexOf() 更加严格不会误判NaN\n    - 是否包含某个值,返回布尔值\n    - [1, 2, 3].includes(2)   // true\n- 9.11 flat(),flatMap() \n    - flat() 扁平化\n        - console.log([1, [2, [3, 4, [5, [6, [7], [8, 9]]], [10]]]].flat(Infinity));\n        // [1,2,3,4,5,6,7,8,9,10];\n    - flatMap() 先对数组所有元素执行一次函数,\n                再进行flat()\n    - [2, 3, 4].flatMap((x) => [x, x * 2])\n    // [2, 4, 3, 6, 4, 8]\n- 9.12 at() 负索引\n    - console.log([1, 2, 3, 4, 5].at(-2)); // 4\n")])])]),o("h2",{attrs:{id:"_10-对象的拓展"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_10-对象的拓展"}},[n._v("#")]),n._v(" 10.对象的拓展")]),n._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",[o("code",[n._v("- 10.1 属性的简洁表达式\n    - function f(x, y) {\n        return { x: x, y: y };\n    }\n    console.log(f(1, 2)); // {x:1,y:2}\n- 10.2 属性名表达式\n    - const obj = new Object();\n      obj['a' + 'bc'] = 123;\n      console.log(obj.abc); // 123\n- 10.3 方法的name属性\n    - const obj = {\n        sayhi() {\n        console.log('hello!');\n        }\n    }\n    console.log(obj.sayhi.name); // sayhi\n    - const k1 = Symbol('I am k1');\n      const k2 = Symbol('I am k2');\n      let obj = {\n          [{'name3':'kz3'}]:'kz3',\n          [name]:'kz1',\n          name: 'kz',\n          [k1]() { },\n          [k2]() { }\n      }\n      console.log(obj[k1].name);\n      console.log(obj.name);\n      console.log(obj[name]);\n      console.log(obj[{'name3':'kz3'}]);\n- 10.4 属性的可枚举性和遍历\n    - 10.4.1 可枚举性\n        - 对象每个属性都有一个描述对象,用来控制该属性的行为\n        - object.getOwnPropertyDescriptor方法可以获取该属性的描述对象\n        - 注意以后少用for in来遍历,而用object.keys()代替\n    - 10.4.2 属性的遍历\n        - ES6的遍历对象方法\n            - for...in    \n                - 遍历可枚举属性(不含Symbol属性)\n            - Object.keys(obj)\n                - 遍历自身可枚举属性的键名(不含Symbol属性),返回一个数组\n            - Object.getOwnPropertyNames(obj)\n                - 遍历自身所有属性的键名(包括不可枚举属性)\n            - Object.getOwnPropertySymbols(obj)\n                - 返回一个数组，包含对象自身的所有 Symbol 属性的键名\n            - Reflect.ownKeys(obj)\n                - 返回一个数组，包含对象自身的（不含继承的）所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举\n    - 10.4.3 super关键字\n        - class Father {\n            constructor(words) {\n                console.log(words);\n                this.word = words\n            }\n            words() {\n                console.log('I am words');\n            }\n          }\n          class Son extends Father {\n              constructor(words) {\n                  super(words)\n              }\n              sayhi() {\n                  console.log('hi');\n              }\n          }\n          let son = new Son('我是根据ES6class继承而来')\n          son.sayhi()\n          son.words()\n          console.log(son.word);\n    - 10.4.4 对象的拓展运算符\n        - 10.4.4.1 解构赋值\n        let { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 }\n        // x=1,y=2,z = {a: 3, b: 4 }\n        - 10.4.4.2 拓展运算法\n        const a = {\n            a: 3,\n            b: 4\n        }\n        const { ...c } = a\n        console.log(c);\n")])])]),o("h2",{attrs:{id:"_11-对象的新增方法"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_11-对象的新增方法"}},[n._v("#")]),n._v(" 11.对象的新增方法")]),n._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",[o("code",[n._v("- 11.1 Object.is() \n    - ES5中的比较两值是否相等\n        == 或者 === \n        == 会自动转换数据类型\n        === NaN不等于自身\n    - 案例:  => 是通过二进制来比较\n    console.log(Object.is('foo', 'foo')); // true\n    console.log(Object.is({}, {})); // false\n    console.log(Object.is(NaN, NaN)); // true\n- 11.2 Object.assign(target, source1, source2...)\n    - 复制可枚举的对象属性到指定的目标对象\n   \n    - 案例: => 注意这里的a,b对象不相同\n    let a = {\n        name: '123456'\n    }\n    let b = {}\n    Object.assign(b, a)\n    console.log(b); // {name:'123456'}\n    - 注意:\n        - 11.2.1 该方法是浅拷贝\n            - 浅拷贝:如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。\n            - 案例:\n                let a = {\n                name: '123456',\n                sex: {\n                    man: '男',\n                    woman: '女'\n                }\n                }\n                let b = {}\n                Object.assign(b, a)\n                a.sex.man = 'nan'\n                // b.name = '789'\n                console.log(b);\n                console.log(a);\n        - 11.2.2 同名属性的替换 \n            - 如果对象中有同名属性,会覆盖整个对象\n            - 案例:\n                const target = { a: { b: 'c', d: 'e' } }\n                const source = { a: { b: 'hello' } }\n                Object.assign(target, source)\n                // { a: { b: 'hello' } }\n        - 11.2.3 数组的处理\n            - console.log(Object.assign([1, 2, 3], [4, 5])); // [4,5,3]\n        - 11.2.4 取值函数的处理\n            - 先返回函数的值,再赋值给函数\n            const source = {\n                get foo() {\n                    return 1\n                }\n            }\n            const target = {};\n            console.log(Object.assign(target, source)); // {foo:1}\n        - 11.2.5 用途\n            - 11.2.5.1 为对象添加属性\n                - 使用Object.assign(this,{x,y})给类对象添加x和y属性\n                - 案例:\n                class person {\n                    constructor(x, y) {\n                        Object.assign(this, { x: '1', y: '2' })\n                    }\n                }\n                let Person = new person();\n                console.log(Person.x);  // 1\n                console.log(Person.y);  // 2\n            - 11.2.5.2 为对象添加方法 \n                - 使用 \n                    Object.assign(a.prototype, {\n                        method1(x) {\n                            ...\n                        },\n                        method2(y) {\n                            ...\n                        }\n                    })\n                    注意这里的a是一个类,然而类的本质是一个函数,所以如果a函数也是可以的\n                - 案例:\n                    class a {\n\n                    }\n                    Object.assign(a.prototype, {\n                        method1(x) {\n                            console.log(x);\n                        },\n                        method2(y) {\n                            console.log(y);\n                        }\n                    })\n                    a.prototype.method1(5)\n                    a.prototype.method2(10)\n            - 11.2.5.3 克隆对象\n                - 由于Object.assign()是浅拷贝,所以不能继承原始对象的值\n                - 可以同时使用Object.getPrototypeOf()和Object.create()进行原型链克隆\n                - 案例:\n                    function clone(origin) {\n                        // 得到origin的原型\n                        let originProto = Object.getPrototypeOf(origin);\n                        return Object.assign(Object.create(originProto), origin)\n                    }  \n            - 11.2.5.4 合并多个对象\n                - 将多个对象合并到某个对象\n                - 案例:\n                    let a = {\n                        name: 'kz'\n                    }\n                    let b = {\n                        sex: '男'\n                    }\n                    let c = {\n                        age: '20'\n                    }\n                    const result = (...source) => Object.assign({}, a, b, c)\n                    console.log(result());\n            - 11.2.5.5 为属性指定默认值\n                - 案例:\n                const DEFAULTS = {\n                    logLevel: 0,\n                    outputFormat: 'html'\n                };\n                function processContent(options) {\n                  options = Object.assign({}, DEFAULTS, options);\n                  console.log(options);\n                  // ...\n                }\n- 11.3 Object.getOwnPropertyDescriptors()\n    - 得到甩多有关其对象的值\n      什么value啊,wirtable等值都有 \n    - 案例:\n    function getOwnPropertyDescriptors(obj) {\n        const result = {};\n        for (const iterator of Reflect.ownKeys(obj)) {\n            result[iterator] = Object.getOwnPropertyDescriptor(obj, iterator)\n        }\n        return result\n    }\n    let obj = {\n        name: 'kz',\n        sex: 'nan',\n        age: '20'\n    }\n    console.log(getOwnPropertyDescriptors(obj));\n- 11.4 __proto__属性,Object.setPrototypeOf(),Object.getPrototypeOf()\n    - 意思在一个对象的原型上添加属性或者方法\n    - 注意不需要用参数接收,会修改原有属性\n    - Object.setProtptypeOf() 写操作  => 设置一个对象的原型对象\n        - 该方法与__proto__相同\n        - 案例:\n            let a = {\n                name: 'kz'\n            }\n            let obj = {}\n            Object.setPrototypeOf(a, obj);\n            // 通过此方法设置a的原型对象属性或方法\n            obj.sex = '男';\n            console.log(a);\n    - Object.getPrototypeOf() 读一个对象的原型对象\n        - 案例:\n            console.log(Object.getPrototypeOf(a, obj.sex)); // sex:'男'\n    - Object.create()       生成一个对象的原型对象\n        - 案例:\n            Object.create(obj)\n            obj.age = '20';\n            console.log(a);\n- 11.5 Object.keys()、Object.values()、Object.entries()\n    - Object.keys()    => 键名\n    - Object.values()  => 键值\n    - Object.entries() => 键值对\n    - 案例:\n        // 使用解构赋值\n        const { keys, values, entries } = Object;\n        let obj = {\n            a: 1,\n            b: 2,\n            c: 3\n        }\n        // Object.keys(obj) for...of遍历键名\n        for (const iterator of keys(obj)) {\n            console.log(iterator);\n        }\n        // Object.values(obj) for...of遍历键值\n        for (const iterator of values(obj)) {\n            console.log(iterator);\n        }\n        // Object.entries(obj) for...of遍历键值对\n        for (const iterator of entries(obj)) {\n            console.log(iterator);\n        }\n- 11.6 Object.fromEntries()  => 数组转对象,就是Object.entries()的逆操作\n    - 案例:\n        console.log(Object.fromEntries([\n            ['foo', '1'],\n            ['foo2', '2']\n        ])); // {foo: '1', foo2: '2'}\n")])])]),o("h2",{attrs:{id:"_12-运算符的拓展"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_12-运算符的拓展"}},[n._v("#")]),n._v(" 12.运算符的拓展")]),n._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",[o("code",[n._v("- 12.1 指数运算符   \n    - 新增 ** 运算 => 从右到左进行次方运算\n    - 案例12.1.1:\n      console.log(2 ** (3 ** 2)); //512\n    - 案例12.1.2: => 多了一个变量接收\n      let a = 2;\n      a **= 3;\n      console.log(a);\n- 12.2 链判断运算符\n    - ?.  => 新增判断运算符\n    - a?.b\n      // 等同于\n      a == null ? undefined : a.b\n    - 案例12.2.1\n      const firstName = message?.body?.user?.firstName || 'default';\n    - 案例12.2.2\n      if (myForm.checkValidity?.() === false) {\n        // 表单校验失败\n        return;\n      }\n      理解:如果前面有定义,就调用自身;没有定义就返回undefined\n- 12.3 Null判断运算符\n    - ??  => 类似 ||\n    - 注意只有当左侧为null或undefined时,才返回右侧值\n    - 案例:配合?.使用\n      const animationDuration = response.settings?.animationDuration ?? 300;\n      如果response.settings是null或undefined，或者response.settings.animationDuration是null或undefined，就会返回默认值300\n- 12.4 逻辑赋值运算符\n    - 12.4.1 或赋值运算符\n      x ||= y\n      // 等同于\n      x || (x = y)\n    - 12.4.2 与赋值运算符\n      x &&= y\n      // 等同于\n      x && (x = y)\n    - 12.4.3 Null赋值运算符\n      x ??= y\n      // 等同于\n      x ?? (x = y)\n")])])]),o("h2",{attrs:{id:"_13-symbol"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_13-symbol"}},[n._v("#")]),n._v(" 13.Symbol")]),n._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",[o("code",[n._v("- 解决对象属性名重复的问题\n- 通过Symbol()函数生成\n- 属于js数据类型之一\n- 13.1 概述\n    - 13.1.1 \n        - 不能使用new关键字\n        - 接受一个字符串作为参数来修饰该Symbol实例\n        - 不可以比较与加减\n    - 13.1.2\n        - 如果参数是一个对象,就会自动调用toString()方法\n        - 可以转换为布尔值,不能转换为数值\n            - 案例:\n              let sym = Symbol();\n              console.log(Boolean(sym)); // true\n- 13.2 Symbol.prototype.description\n    - 作用:输出修饰Symbol类型的描述\n    - 案例:\n        let sym = Symbol('foo');\n        console.log(sym.description); // foo\n- 13.3 作为属性名的Symbol\n    - 作用:Symbol可以作为对象的属性名,做到不重复\n    - 案例:\n        - 第一种写法\n        let sym = Symbol();\n        let a = {};\n        a[sym] = 'Hello';\n        - 第二种写法\n        let a = {\n            [sym]: 'Hello'\n        }\n        - 第三种写法\n        let a = {};\n        Object.defineProperty(a, sym, { value: 'Hello' });\n        console.log(a);\n    - 注意:Symbol作为对象属性时,不能使用点运算符\n          只能通过[]来调用该Symbol属性\n    - 案例:\n        let sym = Symbol('foo')\n        let obj = {\n            [sym]() {\n                console.log('123');\n            }\n        }\n        console.log(obj[sym].name);\n- 13.4 属性名的遍历\n    - Object.getOwnPropertySymbols()方法\n    - 遍历对象中的Symbol值\n    - 案例:\n        let a = Symbol('a');\n        let b = Symbol('b');\n        let obj = {};\n        obj[a] = 'Hello';\n        obj[b] = 'World';\n\n        console.log(Object.getOwnPropertySymbols(obj)); \n        // 0: Symbol(a)\n        // 1: Symbol(b)\n- 13.5 Symbol.for() Symbol.keyFor()\n    - 13.5.1 Symbol.for()\n        - 作用:接收一个字符串,查找是否有以该字符串为描述的Symbol值,\n              如果有就返回该值,没有就创建一个以该字符串为描述的Symbol值\n        - 案例:\n            let s1 = Symbol.for('foo');\n            let s2 = Symbol.for('foo');\n            console.log(s1 === s2);  // true\n        - 注意与Symbol()的区别:\n            - Symbol.for()创建的值会相等\n            - Symbol()创建的值不会相等\n- 13.6 实例:模块的Singleton模式 =>单例模式(创建类身上的方法返回自身)\n    - 理解:\n    在node中引入模块时,可以使用Symbol.for()来创建\n- 13.7 内置的Symbol值\n    - 13.7.1 Symbol.hasInstance属性\n        - 当其他对象调用instanceof判断是否为该对象时,会调用该方法\n        - 案例:\n        const Even = {\n          [Symbol.hasInstance](obj) {\n            return Number(obj) % 2 === 0;\n          }\n        };\n        1 instanceof Even // false\n        2 instanceof Even // true\n        12345 instanceof Even // false\n    - 13.7.2 Symbol.isConcatSpreadable\n        - 当数组使用concat方法时,使用该方法设置是否可以展开\n        - 案例:\n        let arr1 = [1, 2, 3];\n        let arr2 = [4, 5, 6];\n        arr2[Symbol.isConcatSpreadable] = false // 设置arr2不能被展开\n        let result = arr1.concat(arr2);\n        console.log(result);  // [1,2,3,[4,5,6]]\n    - 13.7.3 Symbol.species \n        - 在类继承中使用该方法,创建实例的对象将使用这个属性的返回的函数作为构造函数\n        - 案例:\n        class MyArray extends Array {\n        static get [Symbol.species]() {\n                return Array;\n            }\n        }\n        const a = new MyArray();\n        const b = a.map(x => x);\n        console.log(b instanceof MyArray); // false\n        console.log(b instanceof Array);  // true\n    - 13.7.4 Symbol.match\n        - 当使用str.match()时,如果属性存在,会调用它,返回该方法的返回值\n        - 案例:\n        class MyMatcher {\n            [Symbol.match](string) {\n                return 'hello world'.indexOf(string);\n            }\n        }\n        console.log('e'.match(new MyMatcher())); // 1\n    - 13.7.5 Symbol.replace\n        - 当该对象被String.prototype.replace方法调用时，会返回该方法的返回值。\n        - 案例:\n        const x = {};\n        x[Symbol.replace] = (...s) => console.log(s); \n        'Hello'.replace(x, 'World'); // [\"Hello\", \"World\"]\n    - 13.7.6 Symbol.search\n        - 当该对象被String.prototype.search方法调用时，会返回该方法的返回值。\n        - 案例:\n        class MySearch {\n            constructor(value) {\n              this.value = value;\n            }\n            [Symbol.search](string) {\n              return string.indexOf(this.value);\n            }\n        }\n        'foobar'.search(new MySearch('foo')) // 0\n    - 13.7.7 Symbol.split\n        - 当该对象被String.prototype.split方法调用时，会返回该方法的返回值。\n        - 案例:\n        class MySplitter {\n          constructor(value) {\n            this.value = value;\n          }\n          [Symbol.split](string) {\n            let index = string.indexOf(this.value);\n            if (index === -1) {\n              return string;\n            }\n            return [\n              string.substr(0, index),\n              string.substr(index + this.value.length)\n            ];\n          }\n        }\n\n        'foobar'.split(new MySplitter('foo'))\n        // ['', 'bar']\n\n        'foobar'.split(new MySplitter('bar'))\n        // ['foo', '']\n\n        'foobar'.split(new MySplitter('baz'))\n        // 'foobar'\n    - 13.7.8 Symbol.iterator\n        - 对象的Symbol.iterator属性，指向该对象的默认遍历器方法。\n        - 案例:\n        class Collection {\n          *[Symbol.iterator]() {\n            let i = 0;\n            while(this[i] !== undefined) {\n              yield this[i];\n              ++i;\n            }\n          }\n        }\n        let myCollection = new Collection();\n        myCollection[0] = 1;\n        myCollection[1] = 2;\n        for(let value of myCollection) {\n          console.log(value);\n        }\n        // 1\n        // 2\n")])])]),o("h2",{attrs:{id:"_14-proxy"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_14-proxy"}},[n._v("#")]),n._v(" 14 Proxy")]),n._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",[o("code",[n._v("    - 代理器\n    - 调用proxy下的属性或方法必须经过此机制\n        - 参数\n            - 目标对象\n            - 属性名\n            - 属性值\n    - let proxy = new Proxy({}, {\n        get: function (target, proxyKey) {\n            console.log('get successful');\n        },\n        set: function (target, proxyKey) {\n            console.log('set successful');\n        }\n    })\n    proxy.name      // get successful\n    proxy.name = 35 // set successful\n    - get() 拦截某个属性的读取操作\n        let person = {\n            name: '康振'\n        }\n        let proxy = new Proxy(person, {\n            get(person, attribute) {\n                if (attribute in person) {\n                    return person[attribute]\n                } else {\n                    throw new Error('传入的对象没有该属性')\n                }\n            }\n        })\n        console.log(proxy.name);\n        console.log(proxy.age);\n    - set() 拦截某个属性的赋值操作\n        - 参数\n            - 目标对象\n            - 属性名\n            - 属性值\n            - proxy实例(可选)\n        - 注意\n            - 严格模式下的set必须返回true,不然会报错\n        let validator = {\n        set: function (obj, prop, value) {\n            if (prop === 'age') {\n                if (!Number.isInteger(value)) {\n                    throw new TypeError('The age is not an integer');\n                }\n                if (value > 200) {\n                    throw new RangeError('The age seems invalid');\n                }\n            }\n            // 对于满足条件的 age 属性以及其他属性，直接保存\n            obj[prop] = value;\n            return true;\n            }\n        };  \n    \n        let person = new Proxy({}, validator);\n    \n        person.age = 100;\n    \n        person.age // 100\n        person.age = 'young' // 报错\n        person.age = 300 // 报错\n    - vue数据代理原生JS\n        const handler = {\n            get(target, key) {\n                invariant(key, 'get');\n                return target[key]\n            },\n            set(target, key, value) {\n                invariant(key, 'set');\n                target[key] = value;\n                return true;\n            }\n        };\n        function invariant(key, action) {\n            // 不能修改以_开头的属性或方法\n            if (key[0] === '_') {\n                throw new Error(`Invalid attempt to ${action} private \"${key}\" property`)\n            }\n        }\n        const target = {};\n        const proxy = new Proxy(target, handler);\n        // proxy._data  报错\n        proxy.name\n        proxy.name = 5\n        console.log(proxy.name);\n    - apply()\n        - 拦截函数调用、call和apply操作\n        - 参数\n            - 目标对象\n            - 目标对象的上下文对象（this）\n            - 目标对象的参数数组。\n        - 案例\n        let target = function () {\n            return 'I am the target'\n        }\n        let handler = {\n            apply: function () {\n                return 'I am the proxy'\n            }\n        }\n        let p = new Proxy(target, handler)\n        console.log(p());  // I am the proxy\n    - has()\n        - 判断对象是否含有该属性\n        - 案例\n        let handler = {\n            has(target, key) {\n                if (key[0] === '_') {\n                    return false\n                }\n                return key in target\n            }\n        }\n        let target = { _proxy: 'foo', proxy: 'foo' }\n        let proxy = new Proxy(target, handler);\n        console.log('_proxy' in proxy); // false\n    - construct()\n        - 拦截new命令\n        - 目标对象是一个函数\n        - 必须返回一个对象\n        - 案例\n        const p = new Proxy(function () { }, {\n            construct: function (target, args) {\n                console.log('called:' + args.join(','));\n                return { value: args[0] * 10 }\n            }\n        })\n        console.log((new p(1)).value);\n    - 其他\n        - deleteProperty()           拦截delete操作\n        - defineProperty()           拦截Object.defineProperty()操作\n        - getOwnPropertyDescriptor() 拦截Object.getOwnPropertyDescriptor()\n        - getPrototypeOf()           拦截获取对象原型 \n        - isExtensible()             拦截Object.isExtensible()操作\n        - ownKeys()                  拦截对象自身属性的读取操作\n        - preventExtensions()        拦截Object.preventExtensions()\n        - setPrototypeOf()           拦截Object.setPrototypeOf()方法\n        - Proxy.revocable()          返回一个可取消的 Proxy 实例\n        - this问题\n            - proxy代理后的this会指向Proxy,而不是目标对象\n")])])])])}),[],!1,null,null,null);e.default=r.exports}}]);