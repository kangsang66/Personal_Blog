(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{612:function(e,a,t){"use strict";t.r(a);var n=t(12),s=Object(n.a)({},(function(){var e=this,a=e.$createElement,t=e._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"vue总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue总结"}},[e._v("#")]),e._v(" Vue总结")]),e._v(" "),t("h2",{attrs:{id:"vue-devtools插件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue-devtools插件"}},[e._v("#")]),e._v(" Vue-DevTools插件")]),e._v(" "),t("p",[e._v("拓展功能,让浏览器可以运行Vue")]),e._v(" "),t("h2",{attrs:{id:"模板语法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#模板语法"}},[e._v("#")]),e._v(" 模板语法")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("- 1.插值语法: {{}} \n    xxx是js表达式\n    绑定data中的数据,也可以调用函数、携带参数\n- 2.指令语法\n    v-xx:\n    v-bind  单向数据绑定\n    v-model 双向数据绑定 => 就是取input的value值\n    ...\n")])])]),t("h2",{attrs:{id:"数据绑定"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数据绑定"}},[e._v("#")]),e._v(" 数据绑定")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("- 1.单向数据绑定\n    数据只能通过data改变页面\n- 2.双向数据绑定\n    data与页面数据互相改变\n")])])]),t("h2",{attrs:{id:"el与data的写法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#el与data的写法"}},[e._v("#")]),e._v(" el与data的写法")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("- 1.el两种写法:\n    - 1.1 new Vue时 => el:''\n    - 1.2 挂载时 => $mount('#xx')\n- 2.data两种写法:\n    - 2.1 对象式\n        data:{\n\n        }\n    - 2.2 函数式  => 组件写法\n        data() {\n            return {\n                \n            }\n        },\n")])])]),t("p",[e._v("注意:Vue所管理的函数要写成普通函数,不是Vue所管理的函数要写成箭头函数")]),e._v(" "),t("h2",{attrs:{id:"mvvm模型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#mvvm模型"}},[e._v("#")]),e._v(" MVVM模型")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("- Vue框架的作用就是将数据通过new Vue实例反应到View界面\n")])])]),t("h2",{attrs:{id:"数据代理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数据代理"}},[e._v("#")]),e._v(" 数据代理")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("- 原理: Object.defineProperty(目标对象,'属性或方法'),{\n        - value: 值,\n        - writable: 能否修改值,\n        - enumerable: 能否被遍历,\n        - configurable: 能否被delete\n}\n- 重点:\n    - getter、setter函数通过目标对象监听另一个对象的值是否改变\n- Vue中的数据代理:\n    - 通过new Vue实例来代理data对象中的属性的操作(读/写)\n- 基本原理:\n    - Vue为每个添加到Vue实例上的属性,绑定一个getter、setter函数进行读写操作\n- 注意: data是由$options包裹\n")])])]),t("h2",{attrs:{id:"事件处理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#事件处理"}},[e._v("#")]),e._v(" 事件处理")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("- v-on:xxx或@xxx绑定事件,可以传参\n- 事件修饰符:\n    - .stop    阻止冒泡,默认冒泡 (常用)\n    - .prevent 阻止默认行为      (常用)\n    - .once    事件只触发一次    (常用)\n    - .capture 使用事件捕获,默认不捕获\n    - .self    event.target是当前操作元素才触发\n    - .passive 立即执行事件默认行为 \n    - .native  原生js事件\n- 常见键盘事件\n    - enter \n    - delete\n    - esc\n    - space\n    - tab\n    - up\n    - down\n    - left\n    - right\n    - eg: @click.enter='XXX'\n")])])]),t("h2",{attrs:{id:"computed计算属性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#computed计算属性"}},[e._v("#")]),e._v(" Computed计算属性")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("- get和set函数 => 一般只用简写形式set函数\n- get函数调用时机:\n- 2.1 第一次模板解析时\n- 2.2 当所需的值变化时,重新计算\n- 必须要有返回值\n")])])]),t("p",[e._v("注意:Computed的函数调用时机 => 导致不能使用定时器函数,因为所需值没有变化")]),e._v(" "),t("h2",{attrs:{id:"watch监视属性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#watch监视属性"}},[e._v("#")]),e._v(" watch监视属性")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("- 使用注意:\n    - 属性存在时生效\n    - 当监视的属性变化时,调用该函数\n- API\n    - deep:true => 深度监视 => 适用于监视目标为对象时\n    - immediate:true => 模板解析时调用一次该函数\n    - handler(newvalue,oldvalue) => 一般使用简写形式\n- 简写形式:\n    -  xxx(newvalue,oldvalue){\n        console.log('isHot监视中 => ', newValue, oldValue);\n    }\n- 使用方式:\n    - 1) new Vue实例时\n    - 2) 创建Vue实例后,通过$watch('xxx',{})挂载\n")])])]),t("h2",{attrs:{id:"绑定样式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#绑定样式"}},[e._v("#")]),e._v(" 绑定样式")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('- 绑定class样式\n    - 1. 字符串写法 => 适用于类名不确定,需要动态指定(通过随机数)\n    - 2. 数组写法 => 适用于绑定样式数量不确定、名字也不确定 \n    - 3. 对象写法 => 适用于样式数量确定、名字也确定,但需要动态指定样式\n- 绑定style样式\n    - 1. :style="{fontSize:xxx}" 其中xxx是动态值\n    - 2. :style="[a,b]",其中a,b是对象形式\n')])])]),t("h2",{attrs:{id:"条件渲染"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#条件渲染"}},[e._v("#")]),e._v(" 条件渲染")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("- v-show\n    - display:none实现,结构还在\n    - 适用于切换频率较高的场景\n- v-if\n    - 会破坏原有结构\n    - 适用于切换频率较低的场景\n- v-else-if\n    - 除去v-if之后的依次判断\n- v-else\n    - 除去之前所有的判断\n")])])]),t("p",[e._v("注意:v-if可能会获取不到样式 => 因为结构会消失找不到该元素")]),e._v(" "),t("h2",{attrs:{id:"列表渲染"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#列表渲染"}},[e._v("#")]),e._v(" 列表渲染")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('- v-for\n    - 写法:\n        - v-for:"ele in xxx" \n    - 场景\n        - 遍历数组\n            - v-for="ele in Array"\n        - 遍历对象\n            - v-for="ele in Object"\n        - 遍历字符串(少用)\n            - v-for="ele in String"\n    - 使用注意\n        - v-for(value,key) in Object => value在前,key在后\n- key的作用\n    - key给每个列表添加一个唯一标识,方便Diff算法识别\n    - Diff算法简易过程\n        - 判断key值 => 判断元素 => 判断value值 ...\n        - 生成虚拟DOM / 复用虚拟DOM\n- 列表过滤\n    - 使用computed计算属性最好 => 记住必须要有返回值\n    - 搭配filter / forEach / indexOf 使用\n- 列表排序\n    - 通过一个flag值,选择排序方式\n    - 最后进入函数判断\n    - 搭配三元运算符 / sort 使用\n')])])]),t("p",[e._v("注意:使用v-for时,必须添加上:key值 => 通常使用nanoid / uuid(nanoid的缩小版)")]),e._v(" "),t("h2",{attrs:{id:"数据更新-插入问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数据更新-插入问题"}},[e._v("#")]),e._v(" 数据更新 / 插入问题")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("- 使用前提必须是响应式数据\n- Vue.set() / vm.$set() / this.$set() 可以直接给data中的数据添加\n- 1.1 数组 => 使用不破坏原数组的方法pop、push、shift、unshift等 \n=> 原因:Vue将Array上的方法放在了Vue实例上\n- 1.2 对象 => 直接使用Vue.set(target,key,value)注意不要给data根对象添加属性\n")])])]),t("h2",{attrs:{id:"收集表单数据"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#收集表单数据"}},[e._v("#")]),e._v(" 收集表单数据")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("- 通过双向绑定数据进行存储\n- 获取数据后需要转换为JSON格式\n")])])]),t("h2",{attrs:{id:"过滤器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#过滤器"}},[e._v("#")]),e._v(" 过滤器")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("- 使用\n    - xxx | xxx\n- 只能在Vue2中使用\n- 常用于文本格式化\n- 定义方法:\n    - 局部 \n        - filters:{\n            xxx(){\n                return xxx\n            }\n        }\n    - 全局\n        - Vue.filter('xxx',function(){\n            return xxx\n        })\n")])])]),t("h2",{attrs:{id:"内置指令"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#内置指令"}},[e._v("#")]),e._v(" 内置指令")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("- v-text  获取文本\n- v-html  不推荐使用 => 会影响xss攻击\n- v-cloak 配合css解决出现{{}}的问题\n- v-once  只渲染一次,优化性能\n- v-pre   不需要经过Vue模板解析\n")])])]),t("h2",{attrs:{id:"自定义指令"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#自定义指令"}},[e._v("#")]),e._v(" 自定义指令")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("- 局部\n    - new Vue({\n        directives:{\n           xxx:{\n\n           } \n        }\n    })\n    或\n    - new Vue({\n        directives(){\n\n        }\n    })\n- 全局指令:\n    - Vue.directive(指令名,配置对象)或 Vue.directive(指令名,回调函数)\n- 配置对象中的三个回调函数  \n    - bind      绑定时\n    - inserted  插入页面时\n    - update    重新解析时")])])])])}),[],!1,null,null,null);a.default=s.exports}}]);